[
     {
          "algorithm": "Design a function that calculates offsets by normalizing and weighting features differently, focusing more on minimizing queue lengths and optimizing processing rates, while adjusting the influence of distance and arc length.",
          "code": "import numpy as np\n\ndef compute_offset(distances, arc_lengths, processing_rates, queue_lengths):\n    max_queue = np.max(queue_lengths)\n    max_arc = np.max(arc_lengths)\n    max_process = np.max(processing_rates)\n    \n    queue_offset = -np.log1p(queue_lengths / max_queue) if max_queue > 0 else np.zeros_like(queue_lengths)\n    arc_offset = (1 - arc_lengths / max_arc) * 0.5\n    process_offset = (processing_rates / max_process) * 0.5\n    delay_offset = -distances / 3e5\n    \n    offsets = queue_offset + arc_offset + process_offset + delay_offset\n    offsets = offsets * 0.05\n    \n    return offsets",
          "objective": 1.529,
          "other_inf": null,
          "eval_metrics": {
               "avg_aoi": 0.604765851764812,
               "avg_dropped_ratio": 0.07530120481927711
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef compute_offset(distances, arc_lengths, processing_rates, queue_lengths):\n    queue_offset = -np.log1p(queue_lengths / (np.max(queue_lengths) + 1e-6))\n    arc_offset = (1 - arc_lengths / (np.max(arc_lengths) + 1e-6)) * 0.5\n    process_offset = (processing_rates / (np.max(processing_rates) + 1e-6)) * 0.5\n    delay_offset = -distances / (3e5 + 1e-6)\n    \n    offsets = queue_offset + arc_offset + process_offset + delay_offset\n    offsets = offsets * 0.05\n    \n    return offsets",
          "objective": 1.529,
          "other_inf": null,
          "eval_metrics": {
               "avg_aoi": 0.604765851764812,
               "avg_dropped_ratio": 0.07530120481927711
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef compute_offset(distances, arc_lengths, processing_rates, queue_lengths):\n    queue_offset = -np.log1p(queue_lengths / (np.max(queue_lengths) or 1))\n    arc_offset = (1 - arc_lengths / (np.max(arc_lengths) or 1)) * 0.5\n    process_offset = (processing_rates / (np.max(processing_rates) or 1)) * 0.5\n    delay_offset = -distances / 3e5\n    \n    offsets = queue_offset + arc_offset + process_offset + delay_offset\n    offsets = offsets * 0.05\n    \n    return offsets",
          "objective": 1.529,
          "other_inf": null,
          "eval_metrics": {
               "avg_aoi": 0.604765851764812,
               "avg_dropped_ratio": 0.07530120481927711
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef compute_offset(distances, arc_lengths, processing_rates, queue_lengths):\n    queue_offset = -np.log1p(queue_lengths / (np.max(queue_lengths) or 1))\n    arc_offset = (1 - arc_lengths / (np.max(arc_lengths) or 1)) * 0.5\n    process_offset = (processing_rates / (np.max(processing_rates) or 1)) * 0.5\n    delay_offset = -distances / 3e5\n    \n    offsets = queue_offset + arc_offset + process_offset + delay_offset\n    offsets = offsets * 0.05\n    \n    return offsets",
          "objective": 1.529,
          "other_inf": null,
          "eval_metrics": {
               "avg_aoi": 0.604765851764812,
               "avg_dropped_ratio": 0.07530120481927711
          }
     }
]