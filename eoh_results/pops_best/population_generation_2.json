{
     "algorithm": "The algorithm computes offsets for Q-values based on queue congestion, proximity to the destination, processing speed, and propagation delay to refine routing decisions.",
     "code": "import numpy as np\n\ndef compute_offset(distances, arc_lengths, processing_rates, queue_lengths):\n    speed_of_light = 299792.458  # speed of light in km/s\n    delay_weights = 0.1          # weight for distance delay\n    congestion_penalty = -0.1    # offset for queue length\n    arc_bonus = 0.1              # bonus for low arc length\n    processing_bonus = 0.05       # bonus for high processing rate\n    \n    offsets = np.zeros_like(distances, dtype=float)\n\n    # Compute negative offset for high queue lengths (congestion)\n    offsets += congestion_penalty * queue_lengths\n    \n    # Compute positive offset for low arc lengths (closer to destination)\n    arc_length_bonus = np.where(arc_lengths < np.median(arc_lengths), arc_bonus, 0)\n    offsets += arc_length_bonus\n    \n    # Compute positive offset for high processing rates\n    processing_rate_bonus = processing_rates / np.max(processing_rates) * processing_bonus\n    offsets += processing_rate_bonus\n    \n    # Compute delay based on distance\n    distance_delays = distances / speed_of_light * delay_weights\n    offsets -= distance_delays\n    \n    return offsets",
     "objective": 1.55382,
     "other_inf": null
}